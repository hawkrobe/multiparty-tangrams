---
title: "3"
output:
  html_document: 
    toc: true
---

# Random todos for Veronica

wth happened with game tGuW7nukBHY72yfXn in round 1? we don't have text from them then??

check that role is correctly recording (post transition)
check that when a player is exited they aren't still selecting 
(I think these are not actual issues, but things that seemed to happen when some players were being non-cooperative)
Might be an issue in a couple games - we are getting more correct answers that people still playing in a couple instances in a couple games! (a relatively rare issue, but look into anyway!)

Confirm all sbert analyses on filtered data!

# Much prep(rocessing)
```{r set-up, include=F}
knitr::opts_chunk$set(echo = FALSE, warning=F, message=F)
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))
options(knitr.table.format = "html")
library(tidyverse)
library(jsonlite)
library(here)
library(rlang)
library(lme4)
library(brms)
library(rstanarm)
library(rstan)
library(viridis)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
theme_set(theme_bw())

ParseJSONColumn <- function(x) {
  str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
    fromJSON(flatten = T)
}

##Data import constants
data_location="data/study3"


date_start=lubridate::ymd('2022-10-04') #TODO change

image_location="write-ups/images"

model_location="code/models"


```

```{r, include=F, eval=F}
##This was for determining participant bonuses using the version of data with PID
d.treatments <- read_csv(here(data_location, 'treatments.csv')) %>% rename(treatmentId=`_id`)
# 
d.games <- read_csv(here(data_location, 'games.csv')) %>%
  select(gameId=`_id`, treatmentId, playerIds) %>%
  left_join(d.treatments) %>%
  mutate(playerIds=str_split(playerIds,",")) %>%
  unnest(playerIds) %>%
  select(playerId=playerIds, name)

# d.round_results.raw |> select(speaker, gameId, trialNum) |> unique() |> 
#   group_by(speaker,gameId) |> tally() |> filter(n>1) |> 
#   pull(speaker) -> speakers

d.players <- read_csv(here(data_location, 'players.csv')) %>%
  filter(createdAt>=date_start) %>% 
  rename(playerId=`_id`) %>%
  left_join(d.games) %>%
  select(data.bonus, playerId,id,data.bonus,name) %>%
    filter(!is.na(name)) %>%
  mutate(bonus=round(data.bonus,2),
         #bonus=ifelse(playerId %in% speakers, bonus+2, bonus),
         cost=round(bonus*4/3,2)) %>%
  filter(cost!=0) %>% write_csv(here(data_location, "player_payments.csv")) |> select(id,bonus) %>% write_csv(here(data_location,"for_prolific.csv"))


```



```{r, include=F, eval=F}

treatments <- read_csv(here(data_location,"treatments.csv"))
d.games <- read_csv(here(data_location, 'games.csv')) %>% 
  rename(gameId = `_id`) %>% 
    filter(createdAt >= date_start) |> 
  left_join(treatments |> select(treatmentId=`_id`,name))

ParseJSONColumn <- function(x) {
  str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
    fromJSON(flatten = T)
}
d.chat.raw <- read_csv(here(data_location, 'rounds.csv'), guess_max=10000) %>%
  filter(createdAt >= date_start) %>%
  mutate(data.chat = ifelse(is.na(data.chat), '{}', data.chat)) %>%
  rename(row_id = `_id`) %>% 
  mutate(data.chat = map(data.chat, .f = ParseJSONColumn)) %>% 
  unnest(data.chat) %>% 
  select(-data.target, -ends_with('response'), -ends_with('_correct'), -ends_with('time')) %>% 
  rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>% 
  filter(type=="message") %>% 
  write_csv(here(data_location, 'raw_chat.csv'))

library(data.table)
d.round_results.raw <- read.csv(here(data_location,'rounds.csv')) |> 
  setDT() |> 
  filter(createdAt >= date_start) %>% 
  rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>% 
  rename_with ( ~ gsub("room", "player", .x, fixed=T)) %>% 
    rename_with ( ~ gsub("player", "player_", .x, fixed=T)) %>% 
    rename_with ( ~ gsub("correct", "_correct", .x, fixed=T)) %>% 
    rename_with ( ~ gsub("response", "_response", .x, fixed=T)) %>% 
  rename_with( ~ gsub("time", "_time", .x, fixed=T)) |> 
  select(-chat) |> 
  pivot_longer(cols=starts_with('player'), names_to=c("playerId", "info"), names_prefix="player__", names_sep="__",
               values_to="values", values_transform=as.character, values_drop_na=T) |> 
  filter(values!="") |> 
  filter(playerId!=speaker) %>% 
  pivot_wider(names_from=info, values_from=values) %>% 
  filter(!is.na(correct)) |> 
  mutate(tangram = gsub('/experiment/tangram_', '', target, fixed=TRUE),
         tangram = gsub('.png', '', tangram, fixed=TRUE),
         correct=as.logical(correct),
         time=as.numeric(time)/1000) |> 
  write_csv(here(data_location, 'raw_results.csv'))

d.exit.survey <- read_csv(here(data_location, 'player-inputs.csv')) %>%
  filter(createdAt >= date_start) %>%
  left_join(d.games, by = c('gameId')) %>%
    rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>% 
    write_csv(here(data_location,'exit.csv'))


```

```{r, include=F, eval=F}
#we exclude rounds where no one talked (this is our criteria for "they weren't playing anymore")
# this is better than if no one submitted b/c maybe people fail to click on some round?

rounds_include <- (read_csv(here(data_location,'raw_chat.csv'))) %>% 
  filter(role=="speaker") %>% 
  filter(!is.na(text)) %>%
  filter(gameId!="MhCsn5ZQTvFv49Bwy") |> # ***** just excluding this game by fiat -- the assigned speaker seemed to either really, really not be fluent or not understand the game. They do not provide descriptions and only barely answer when the listeners play 20 questions. ******
  select(gameId,numPlayers,repNum,targetNum) %>% unique() %>% 
  group_by(gameId,numPlayers,repNum) %>% tally() %>% 
  filter(n==12) %>% select(gameId,repNum) |> 
  left_join(d.games |> select(gameId,name)) |> 
  write_rds(here(data_location,"rounds_include.rds"))

d.round_results <-(read_csv(here(data_location,'raw_results.csv'))) %>% inner_join(rounds_include) %>% write_rds(here(data_location,'round_results.rds'))

d.correct <- d.round_results %>% 
  group_by(`X_id`,gameId,target,targetNum,repNum,trialNum,
           numPlayers,countCorrect,speaker,tangram) %>% 
  summarize(realCorrect=sum(ifelse(correct,1,0)))

d.round_results %>% left_join(d.correct) %>% 
  left_join(d.games |> select(gameId, name)) |> write_rds(here(data_location,"round_results.rds"))

d.exit_survey <- (read_csv(here(data_location,'exit.csv'))) %>% 
  write_csv(here(data_location,"exit_survey.csv"))
  
```
# Descriptives

How many games:

Note -- one 6 p thick game excluded by fiat -- the assigned speaker seemed to either really, really not be fluent or not understand the game. They do not provide descriptions and only barely answer when the listeners play 20 questions.

Aimed for 40 each. 

Partial means it didn't go all the rounds, reduced means it has fewer people than it started out with. (Note we also started games even if they were incomplete, so there might be more classification adventures there. )

```{r}
d.round_results <- read_rds(here(data_location, "round_results.rds")) 

d.round_results%>% group_by(gameId,name, numPlayers) %>% 
  summarize(max_rep=max(repNum),
            min_active=min(activePlayerCount)) %>% 
  mutate(game_length=case_when(
    max_rep!=5 ~ "partial",
    min_active!=numPlayers ~ "reduced",
    T ~ "complete")) %>% 
  group_by(name, game_length) %>% 
  tally() %>% 
  pivot_wider(names_from="game_length",values_from="n")
```

```{r}
d.round_results |> select(gameId, name, numPlayers, trialNum, activePlayerCount) |> 
  filter(name %in% c("6_thick", "6_thin")) |> 
  unique() |> 
  ggplot(aes(x=trialNum, fill=as.factor(activePlayerCount)))+geom_bar()+facet_grid(.~name)

```

How long full games took

Note that this is inaccurate for games where some players kept the tab open but didn't respond (but we don't have an easy way to distinguish "exited" from "inactive, but tab open" in this record). 

```{r}
summary <- d.round_results %>% group_by(trialNum, repNum, gameId, name) %>% 
           mutate(time= time %|% 0) %>% # empties are either that they didn't answer or that they were already exited (should adjust recording for future!). This slighlty lowballs 
  summarize(max_time=max(time)) %>% 
  group_by(gameId, name) %>% 
  summarize(total_time=sum(max_time)/60,
            num_rounds=max(repNum)) %>% 
  arrange(name)

message("Full games")

summary %>% filter(num_rounds==5) %>% 
  group_by(name) %>% 
  summarize(games=n(),
            min_time=min(total_time) %>% round(),
            `25th_time`=quantile(total_time, .25)%>% round(),
            median_time=quantile(total_time, .5)%>% round(),
            `75th_time`=quantile(total_time, .75)%>% round(),
            max_time=max(total_time)%>% round()) 

```







```{r chat}

rounds_include <- read_rds(here(data_location,"rounds_include.rds"))
d.round_results <- read_rds(here(data_location,"round_results.rds"))

d.chat.filter <- read_csv(here(data_location, "filtered_chat.csv")) |> 
  filter(!is.chitchat) %>% 
  filter(!is.na(target)) |> 
  mutate(text = gsub("\\n", '', fixed = T, spellchecked), # note that this is using spellcorrected version!!!!
         text = gsub("[/?/.]", ' ', text),
         text = str_squish(text),
         tangram = gsub('/experiment/tangram_', '', target, fixed=TRUE),
         tangram = gsub('.png', '', tangram, fixed=TRUE),
         utt_length_chars = str_length(text), 
         utt_length_words = str_count(text, "\\W+") + 1) %>%
  group_by(gameId, trialNum, repNum, tangram) %>% 
  mutate(is.firstutter=ifelse(role!="speaker",F,NA)) %>% 
  fill(c("is.firstutter"), .direction="down") %>% 
  mutate(is.firstutter= is.firstutter %|% T) 

d.chat <- d.chat.filter %>% 
  group_by(gameId, trialNum, repNum, tangram, playerId, role, numPlayers) %>%
  summarize(text = paste0(text, collapse = ', '),
            total_num_words = sum(utt_length_words, na.rm=T) %>% as.numeric(),
            total_num_chars = sum(utt_length_chars, na.rm=T) %>% as.numeric()) %>%
  inner_join(rounds_include) %>% 
  full_join(d.round_results, c("gameId", "trialNum", "repNum", "playerId", "tangram", "numPlayers", "name")) %>% 
  mutate(text = text %|% "",
         total_num_words= total_num_words %|% 0,
         total_num_chars= total_num_chars %|% 0,
         role = role %|% "listener")

d.listener <- read_csv(here(data_location,"raw_chat.csv")) %>% filter(role=="listener") %>% inner_join(rounds_include)

d.chat.pre <- d.chat.filter %>% group_by(gameId, trialNum, repNum, tangram, playerId, is.firstutter,role, numPlayers) %>%
  summarize(text = paste0(text, collapse = ', '),
            total_num_words = sum(utt_length_words, na.rm=T) %>% as.numeric(),
            total_num_chars = sum(utt_length_chars, na.rm=T) %>% as.numeric()) %>%
  inner_join(rounds_include) %>% 
  ungroup() %>% 
  mutate(text = text %|% "",
         total_num_words= total_num_words %|% 0,
         total_num_chars= total_num_chars %|% 0,
         role = role %|% "listener") %>% 
  filter(is.firstutter)

```

# Many graphs

 
Everything here has bootstrapped 95% CIs. 

Should find better curves to fit, but using quadratic to allow for some curvature.

```{r}
d.chat %>% filter(role=="speaker") %>% 
    mutate(groupxtangram=str_c(gameId,tangram)) %>% 
  group_by(repNum, gameId,tangram, groupxtangram, name) %>% 
  summarize(words=sum(total_num_words)) |> 
ggplot(aes(x=repNum, y=words, color=name))+
  facet_wrap(.~name, nrow=1)+
  scale_color_brewer(palette="Dark2")+
    geom_line(aes(group=groupxtangram), alpha=.05,method=glm, se=F)+
  coord_cartesian(y=c(0,60))+
    #geom_smooth(method = "glm", formula = y~x,method.args = list(family = gaussian(link = 'log')))+
    geom_smooth(method=glm, formula=y~poly(x,2), alpha=.3)+
  labs(title="Words from speaker per tangram", y="Number of words", x="Round number", color="Player count")+
  theme(legend.position="null")

d.chat %>% filter(role=="speaker") %>% 
    #mutate(groupxtangram=str_c(gameId,tangram)) %>% 
  group_by(repNum, gameId, name) %>% 
  summarize(words=sum(total_num_words)) |> #View()
ggplot(aes(x=repNum, y=words, color=name))+
  facet_wrap(.~name, nrow=1)+
  scale_color_brewer(palette="Dark2")+
    geom_line(aes(group=gameId), alpha=.5,method=glm, se=F)+
  #coord_cartesian(y=c(0,60))+
    #geom_smooth(method = "glm", formula = y~x,method.args = list(family = gaussian(link = 'log')))+
    geom_smooth(method=glm, formula=y~poly(x,2), alpha=.3)+
  labs(title="Words from speaker per round", y="Number of words", x="Round number", color="Player count")+
  theme(legend.position="null")

```

```{r}
d.chat %>% filter(role=="speaker") %>% 
ggplot(aes(x=repNum, y=total_num_words, color=name))+
  facet_wrap(~tangram)+
  scale_color_brewer(palette="Dark2")+
    geom_smooth(method=glm, formula=y~poly(x,2), se=T, alpha=.1)+
    #  geom_smooth(method = "glm", formula = y~x,method.args = list(family = gaussian(link = 'log')))+
       stat_summary(fun.data = "mean_cl_boot", size=.2)+
  labs(title="Tangram variability", y="Number of words", x="Round number", color="Player count")+
  theme(legend.position="bottom")


```



```{r accuracy}
#Note: as a result of 5 high looking lower, we adjusted the inclusion criteria to exclude the game where people didn't select responses after the first round, but one listner kept sending "is anyone there?" type messages to the chat the *entire* game. (This is probably a minor software issue since maybe others had disconnected?)

d.round_results %>% group_by(playerId,repNum, gameId, name) %>% 
  filter(response!="false") |> 
  mutate(correct.num=ifelse(correct,1,0)) %>% 
  ggplot(aes(x=repNum, y=correct.num, color=name))+
geom_smooth(method = "glm", method.args = list(family = "binomial")) + 
  stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width=.2))+
  #geom_point()+
  scale_color_brewer(palette="Dark2")+
  #scale_y_continuous(limits = c(0,1))+
  labs(x="Round Number", y="Fraction correctly selected", title= "Overall accuracy increases over repetitions", color="Player count")+
    theme(legend.position="bottom")

  
```

Note that this accuracy is of players who clicked something!


```{r time}
d.round_results %>% group_by(playerId, repNum, gameId, name) %>% 
  filter(correct==T) %>% 
  #summarize(time=mean(time)) %>% 
  ggplot(aes(x=repNum, y=time, color=name))+
  geom_jitter(width=.4, height=0, alpha=.01)+
geom_smooth(method = "glm", formula = y~x,
                      method.args = list(family = gaussian(link = 'log')))+
  stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width=.2))+
  scale_y_continuous(limits = c(0,180))+
    scale_color_brewer(palette="Dark2")+
  labs(x="Round Number", y="Time to selection in seconds",
       title="People choose faster in later rounds", color="Player count")+
  theme(legend.position = "bottom")


```

# Prep Sbert
Should we do this on filtered (chit-chat free) and/or spell checked sample?
```{r, include=F, eval=F}
rounds_include <- read_rds(here(data_location,"rounds_include.rds"))
d.round_results <- read_rds(here(data_location,"round_results.rds"))

d.pre.sbert <- read_csv(here(data_location, "filtered_chat.csv")) |> 
  #filter(!is.chitchat) %>% 
  filter(!is.na(target)) |> 
    filter(!is.na(text)) %>% 
  mutate(tangram = gsub('/experiment/tangram_', '', target, fixed=TRUE),
         tangram = gsub('.png', '', tangram, fixed=TRUE)) %>%
  inner_join(rounds_include) |>
  separate(name, into=c("playerCond","channelCond")) |> 
  select(gameId, targetNum, repNum, trialNum, playerCond, channelCond, activePlayerCount,playerId, tangram, role, text) |>
  group_by(gameId, targetNum, repNum, trialNum, playerCond, channelCond, activePlayerCount,playerId, tangram, role) |>  summarize(sentence=str_c(text, collapse=" ")) |> 
  ungroup() |> 
  write_csv(here(data_location,"pre_sbert.csv"))
```


```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load(here(data_location,'post_sbert.npy'))
saveRDS(mat,here(data_location,'post_sbert.RData'))

```

```{r}
sbert_concat <- read_csv(here(data_location,"pre_sbert.csv")) |>   bind_cols(readRDS(here(data_location,'post_sbert.RData'))  %>% as_tibble())

F_mat <- sbert_concat %>% select(starts_with("V")) %>% as.matrix() #Features
M_mat <- sbert_concat %>% select(-starts_with("V")) %>% mutate(feature_ind=row_number())
```

```{r helpers}
# note: cor expects features to be in columns so we transpose
get_sim_matrix = function(df, F_mat, method = 'cosine') {
  feats = F_mat[df$feature_ind,]
  if(method == 'cor') {
    return(cor(t(feats), method = 'pearson'))
  } else if (method == 'euclidean') {
    return(as.matrix(dist(feats, method = 'euclidean')))
  } else if (method == 'cosine') {
    return(as.matrix(lsa::cosine(t(feats))))
  } else {
    stop(paste0('unknown method', method))
  }
}

# note this does de-duplicated version
flatten_sim_matrix <- function(cormat, ids) {
  ut <- upper.tri(cormat)
  data.frame(
    dim1 = ids[row(cormat)[ut]],
    dim2 = ids[col(cormat)[ut]],
    sim  = as.numeric(cormat[ut])
  ) %>%
    mutate(dim1 = as.character(dim1),
           dim2 = as.character(dim2))
}

make_within_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          .$repNum)) %>%
    mutate(rep1 = as.numeric(dim1), 
           rep2 = as.numeric(dim2)) 
}

make_across_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          as.character(.$combinedId)))
}
```

# Sbert results

## Across game divergence

```{r}

game_divergence <- M_mat %>% 
  filter(role=="speaker") %>% 
  group_by(tangram,repNum, channelCond,playerCond) %>% 
  mutate(combinedId=str_c(gameId,repNum,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("gameId_1","repNum_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("gameId_2","repNum_2"), convert=T, sep="_") %>% 
  filter(gameId_1!=gameId_2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup()

```

```{r}
ggplot(game_divergence, aes(x=repNum+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(playerCond, channelCond,tangram), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+

  geom_smooth(formula=y~poly(x,2))+

  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity", x="Block", color="Cond")+
  theme(text=element_text(size=14), legend.position="bottom")+
    scale_color_viridis(discrete=T, direction=-1)
  #coord_cartesian(ylim=c(0.1,.6))

```

## Within game divergence

```{r }

tangram_distinctive <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(gameId,repNum, channelCond,playerCond) %>% 
  mutate(combinedId=tangram) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  rename(tangram1=dim1,tangram2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(tangram1!=tangram2) %>% 
  ungroup()
```


```{r, }
ggplot(tangram_distinctive, aes(x=repNum+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(gameId), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+

  geom_smooth(formula=y~poly(x,2))+

  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity of descriptions \n of different tangrams within a game", x="Block", color="Players")+
  theme(text=element_text(size=14))+
    scale_color_viridis(discrete=T, direction=-1)
  #coord_cartesian(ylim=c(0.1,.6))

```

## Within game similarity

```{r}

tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(tangram, gameId, playerCond,channelCond) %>% 
  mutate(combinedId=str_c(repNum,playerId,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","p1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","p2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1),
         samespeaker=ifelse(p1==p2,"same_speaker","diff_speaker")) 

adjacent <- tangram_change %>% 
  filter(earlier+1==later) %>% 
  ungroup()

to_first <- tangram_change |> filter(earlier==0) |> ungroup()

to_last <- tangram_change |> filter(later==5) |> ungroup()
```


```{r}

 ggplot(to_first, aes(x=later+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(gameId), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+
  geom_smooth(formula=y~poly(x,2))+
  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity to ...", x="Block",title="first block")+
    scale_color_viridis(discrete=T, direction=-1)

 ggplot(adjacent, aes(x=earlier+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(gameId), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+
  geom_smooth(formula=y~poly(x,2))+
  scale_x_continuous(breaks=seq(1,6))+
  labs(y="", x="Block")+
  ggtitle("next block")+
    scale_color_viridis(discrete=T, direction=-1)

 ggplot(to_last, aes(x=earlier+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(gameId), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+
  geom_smooth(formula=y~poly(x,2))+
  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity", x="Block", color="Players", title="Similarity to description in final block")+
    scale_color_viridis(discrete=T, direction=-1)

```

# CAMP graphs

```{r}
#good
library(cowplot)
reduction <-  d.chat %>% filter(role=="speaker") %>% 
    mutate(groupxtangram=str_c(gameId,tangram)) %>% 
  group_by(repNum, gameId,tangram, groupxtangram, name) %>% 
  summarize(words=sum(total_num_words)) |> 
  #group_by(repNum, name, gameId) |> 
  #summarize(words=sum(words)) |> 
ggplot(aes(x=repNum+1, y=words, color=name))+
   scale_color_brewer(palette="Paired", direction=-1)+
      geom_point(size=1, alpha=.05, position = position_dodge(width=.4))+
    geom_smooth(method=glm, formula=y~poly(x,2), alpha=.3)+
  coord_cartesian(ylim=c(0,60))+
       scale_x_continuous(breaks=seq(1,6))+
  labs( y="Number of words", x="Block", color="")+
  annotate("text", x=6, y=60,label="Words from speaker per tangram", color="black", size=6, hjust=1)+
    annotate("text", x=6, y=50,label="Speakers say more in 6p games \n and less in later blocks", color="black", size=6, hjust=1)+
  theme(legend.position="none",
        text=element_text(size=16))

for_legend <-d.chat %>% filter(role=="speaker") %>% 
    mutate(groupxtangram=str_c(gameId,tangram)) %>% 
  group_by(repNum, gameId,tangram, groupxtangram, name) %>% 
  summarize(words=sum(total_num_words)) |> 
ggplot(aes(x=repNum+1, y=words, color=name))+
   scale_color_brewer(palette="Paired", direction=-1)+
      geom_point(size=1, alpha=.05, position = position_dodge(width=.4))+
  labs(y="Number of words", x="Block", color="")+
  theme(legend.position="bottom", legend.text = element_text(size=18))+
  guides(color=guide_legend(override.aes=list(linetype=0, alpha=1, size=7)))

# good
 accuracy <- d.round_results %>% group_by(playerId,repNum, gameId, name) %>% 
  filter(response!="false") |> 
  mutate(correct.num=ifelse(correct,1,0)) %>% 
  ggplot(aes(x=repNum+1, y=correct.num, color=name))+
     scale_x_continuous(breaks=seq(1,6))+
geom_smooth(method = "glm", method.args = list(family = "binomial")) + 
  stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width=.2))+
  labs(x="Block", y="Fraction correctly selected", color="")+
       annotate("text", x=2, y=.98,label="Listener Accuracy", color="black", size=6, hjust=0)+
    annotate("text", x=6, y=.75,label="Accuracy increases,\n condition differences remain", color="black", size=6, hjust=1)+
  theme(legend.position="none",
        text=element_text(size=16))+
        scale_color_brewer(palette="Paired", direction=-1)

 diverge <- ggplot(game_divergence, aes(x=repNum+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(playerCond, channelCond,tangram), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+
  geom_smooth(formula=y~poly(x,2))+
  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity", x="Block", color="")+
 annotate("text", x=6, y=.58,label="Similarity of descriptions\n across games", color="black", size=6, hjust=1)+
    annotate("text", x=1, y=.23,label="6_thin develops\nless group-specific names", color="black", size=6, hjust=0)+
  theme(legend.position="none",
        text=element_text(size=16))+
   scale_color_brewer(palette="Paired", direction=-1)


 converge <- ggplot(to_last, aes(x=earlier+1,y=sim,color=str_c(playerCond, channelCond)))+
      stat_summary(aes(group=str_c(gameId), color=str_c(playerCond, channelCond)),fun.data = "mean_cl_boot", position = position_dodge(width=.3), alpha=.5, geom="point")+
  geom_smooth(formula=y~poly(x,2))+
  scale_x_continuous(breaks=seq(1,6))+
  labs(y="Cosine Similarity", x="Block", color="")+
 annotate("text", x=5, y=.33,label="Similarity to description\n in final block", color="black", size=6, hjust=1)+
    annotate("text", x=5, y=.15,label="Thick games and 2p games\n converge faster", color="black", size=6, hjust=1)+
  theme(legend.position="none",
        text=element_text(size=16))+     scale_color_brewer(palette="Paired", direction=-1)

```
```{r, fig.width=10, fig.height=10}

row1 <- plot_grid(reduction,accuracy, labels=c("A","B"), label_size=18, label_x=.15, label_y=.95)
row2 <- plot_grid(get_legend(for_legend))
row3 <- plot_grid(diverge, converge, labels=c("C","D"), label_size=18, label_x=.15, label_y=.95)

p <- plot_grid(row1,row2,row3, nrow=3, rel_heights = c(1,.1,1))

save_plot(here(image_location,"CAMP1.pdf"),p, base_width=10, base_height=10)
#save_plot(here(image_location,"CAMP1.png"),p, base_width=10, base_height=10)

```



# Models
From pre-reg

We will do graphical visualizations for accuracy, time taken and utterance reduction. 
 
Our primary analysis will be a Bayesian mixed model for utterance reduction in the words written by the speaker on each trial: 
words ~ block*channel*group_size + (block*channel*group_size|tangram)+ (1|tangram*group)+(block|group)

We will also run a logistic Bayesian mixed model on listener accuracy:
listener_accurate ~ block*channel*group_size + (block*channel*group_size|tangram)+ (1|tangram*group)+(block|group)
Additionally, we will analyse the effect of the language. Using SBERT embeddings we will embed the concatenation of everything the speaker said in a trial. We will then take pairwise cosine distances of these to look at the following effects. :
(divergence across games) For the same condition & block & tangram, distance between utterances from different games. 
(divergence within games) For the same condition & block & game, distance between utterances for different tangrams.
 (convergence within games) For the same condition & game & tangram, distance between utterances from different blocks. We plan to look at the similarities for block 1 with all later blocks; block 6 with all earlier blocks; and block N with block N+1. 
(Note: these SBERT analyses were done as exploratory analyses on the earlier collected conditions.)
Additionally, exclusive to the thin channel parts of this condition, we will analyse the distribution of emoji’s produced as a function of block and its relation to accuracy and speaker utterance length. 

## Reduction of words

rerun for longer with fuller mixed effects

```{r, eval=F, include=F}
chat_mod <- d.chat |> filter(role=="speaker") |>
  group_by(gameId, repNum, tangram, playerId, name) |> 
  summarize(words=sum(total_num_words)) |> 
  separate(name, into= c("gameSize","channel"))

red_prior <- c(set_prior("normal(12,20)", class="Intercept"),
               set_prior("normal(0,10)", class="b"),
               set_prior("normal(0,5)", class="sd"),
              set_prior("lkj(1)", class="cor")
               )

red_model <- brm(words ~ repNum*channel*gameSize + 
                (repNum*channel*gameSize|tangram)+
                          (1|tangram:gameId)+
                          (repNum|gameId), 
                 data=chat_mod,
                 file=here(model_location,"red_model_study3_mix.rds"),
                 control=list(adapt_delta=.99),
                 prior=red_prior)


```

```{r} 
read_rds(here(model_location,"red_model_study3_mix.rds")) |> summary()

```

## Accuracy model

```{r, eval=F, include=F}
acc_data <- d.round_results %>% select(playerId,repNum, gameId, name, tangram, response, correct) |> 
  filter(response!="false") |> 
  mutate(correct.num=ifelse(correct,1,0)) |> 
    separate(name, into= c("gameSize","channel"))
  


acc_priors <- c(set_prior("normal(0,1.5)", class="Intercept"),
               set_prior("normal(0,.5)", class="b"),
               set_prior("normal(0,.1)", class="sd"),
               set_prior("lkj(1)", class="cor"))
               
acc_model <- brm(correct.num ~ repNum*channel*gameSize+
                          (repNum*channel*gameSize|tangram)+
                          (1|tangram:gameId)+
                          (repNum|gameId), 
                        family=bernoulli(link="logit"),
                        data=acc_data,
                        control=list(adapt_delta=.99),
                        file=here(model_location,"acc_model_study3_mix.rds"),
                        prior=acc_priors)

```

```{r} 
read_rds(here(model_location,"acc_model_study3_mix.rds")) |> summary()

```

## Sbert models

```{r, eval=F, include=F}
game_divergence <- M_mat %>% 
  filter(role=="speaker") %>% 
  group_by(tangram,repNum, channelCond,playerCond) %>% 
  mutate(combinedId=str_c(gameId)) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  rename(gameId_1=dim1, gameId_2=dim2) |> 
  filter(gameId_1!=gameId_2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup() |> 
  mutate(gameSize=as.factor(playerCond)) |> 
  rename(channel=channelCond)

sbert_priors <- c(set_prior("normal(.5, .2)", class="Intercept"),
               set_prior("normal(0,.1)", class="b"),
               set_prior("normal(0,.05)", class="sd"))#,
              # set_prior("lkj(1)", class="cor")
               
game_div_model <- brm(sim ~ repNum*channel*gameSize+
                          #(repNum*channel*gameSize|tangram)+
                         (1|tangram),
                         # (repNum|gameId), 
                        data=game_divergence,
                        control=list(adapt_delta=.95),
                        file=here(model_location,"div_model_study3_mix.rds"),
                        prior=sbert_priors)


tangram_distinctive <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(gameId,repNum, channelCond,playerCond) %>% 
  mutate(combinedId=tangram) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  rename(tangram1=dim1,tangram2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(tangram1!=tangram2) %>% 
  ungroup() |> 
  mutate(gameSize=as.factor(playerCond)) |> 
  rename(channel=channelCond)

tangram_div_model <- brm(sim ~ repNum*channel*gameSize+
                         (1|gameId),
                         # (repNum|gameId), 
                        data=tangram_distinctive,
                        control=list(adapt_delta=.95),
                        file=here(model_location,"tangram_model_study3_mix.rds"),
                        prior=sbert_priors)

tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(tangram, gameId, playerCond,channelCond) %>% 
  mutate(combinedId=str_c(repNum,playerId,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","p1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","p2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1),
         samespeaker=ifelse(p1==p2,"same_speaker","diff_speaker")) 

adjacent <- tangram_change %>% 
  filter(earlier+1==later) %>% 
  ungroup()

to_first <- tangram_change |> filter(earlier==0) |> ungroup()

to_last <- tangram_change |> filter(later==5) |> ungroup() |> 
  mutate(gameSize=as.factor(playerCond)) |> 
  rename(channel=channelCond)

to_last_model <- brm(sim ~ earlier*channel*gameSize*samespeaker,
                          #(repNum*channel*gameSize|tangram)+
                         # (1|tangram:gameId)+
                         # (repNum|gameId), 
                        data=to_last,
                        control=list(adapt_delta=.95),
                        file=here(model_location,"to_last_model_study3.rds"),
                        prior=sbert_priors)
```

```{r} 
read_rds(here(model_location,"div_model_study3_mix.rds")) |> summary()

read_rds(here(model_location,"tangram_model_study3_mix.rds")) |> summary()

read_rds(here(model_location,"to_last_model_study3.rds")) |> summary()



```
