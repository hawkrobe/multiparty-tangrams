---
title: "Embeddings"
output:
  html_document:
    df_print: paged
---


```{r set-up, include=F}
knitr::opts_chunk$set(echo = FALSE, warning=F, message=F, cache=F)
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))
options(knitr.table.format = "html")
library(tidyverse)
library(jsonlite)
library(here)
library(rlang)
library(lme4)
library(brms)
library(rstan)
library(tidytext)
library(viridis)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
theme_set(theme_bw())

ParseJSONColumn <- function(x) {
  str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
    fromJSON(flatten = T)
}

##Data import constants
data_location="data/study1"
##Data import constants
data_location_noro="data/study2a"




date_start=lubridate::ymd('2021-05-04')

image_location="write-ups/images"

model_location="code/models"
```

# Pre-wrangle

Want a data format that has the utterances divied up for throwing into sbert

take 1:
- divide on end punctuation (.!?) and on returns
- include speaker and listener (easy to filter later)

?: do we use the pre or post filtered/cleaned?
here we'll use raw (no spellcheck, no filter)
```{r prep,}

raw_text <- read_csv(here(data_location, "filtered_chat.csv")) %>%
  select(gameId,targetNum,repNum,trialNum,numPlayers,text, playerId, target, role) %>% 
  unnest_tokens(sentence, input=text, token="sentences") %>% 
  filter(!is.na(sentence)) %>% 
  mutate(numPlayers=as.character(numPlayers))

noro <- read_csv(here(data_location_noro, "filtered_chat.csv")) %>% 
  select(gameId,targetNum,repNum,trialNum,numPlayers,text, playerId, target, role) %>% 
  unnest_tokens(sentence, input=text, token="sentences") %>% 
  filter(!is.na(sentence)) %>% 
  mutate(numPlayers="6noro")

#sample <- raw_text %>% filter(gameId=="3WzEi9zkHF77vdTw5") %>% write_csv("sample.csv")
pre_sbert <- raw_text %>%union(noro) %>%  write_csv("pre_sbert.csv")
```

take two : we concatenate everything (with a space)
 still no spellcheck or filtering
 
```{r prep_concatenate,}

raw_text <- read_csv(here(data_location, "filtered_chat.csv")) %>%
  select(gameId,targetNum,repNum,trialNum,numPlayers,text, playerId, target, role) %>% 
  #unnest_tokens(sentence, input=text, token="sentences") %>% 
  filter(!is.na(text)) %>% 
  group_by(gameId, targetNum, repNum, trialNum, numPlayers, playerId, target, role) %>% 
  summarize(sentence=str_c(text, collapse=" ")) %>% 
  mutate(numPlayers=as.character(numPlayers)) %>% 
  ungroup()

noro <- read_csv(here(data_location_noro, "filtered_chat.csv")) %>% 
  select(gameId,targetNum,repNum,trialNum,numPlayers,text, playerId, target, role) %>% 
  #unnest_tokens(sentence, input=text, token="sentences") %>% 
  filter(!is.na(text)) %>% 
  group_by(gameId, targetNum, repNum, trialNum, numPlayers, playerId, target, role) %>% 
  summarize(sentence=str_c(text, collapse=" ")) %>% 
  ungroup() %>% 
  mutate(numPlayers="6noro")

#sample <- raw_text %>% filter(gameId=="3WzEi9zkHF77vdTw5") %>% write_csv("sample.csv")
pre_sbert_concat <- raw_text %>%union(noro) %>%  write_csv("pre_sbert_concat.csv")
```

# Interlude
This is where they need to get embedding with jupyter

# Post-wrangle

```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load('post_sbert.npy')
saveRDS(mat,'post_sbert.RData')
```

```{r, include=F, eval=F}
library(reticulate)
np <- import("numpy")
mat = np$load('post_sbert_concat.npy')
saveRDS(mat,'post_sbert_concat.RData')
```

## separate approach
We embed each sentence separately, but then average across the embeddings to get a vector for each player:trial combo.

```{r, include=F,}
ssb <- pre_sbert %>% bind_cols(readRDS('post_sbert.RData')  %>% as_tibble())


grouped <- ssb %>%
  mutate(tangram=str_sub(target,-5,-5)) %>% 
  group_by(gameId,targetNum,repNum, trialNum, numPlayers,playerId,tangram,role) %>% 
  summarize(across(starts_with('V'), mean)) %>% 
  ungroup() 


```





## concat approach

```{r, include=F,}
sbert_concat <- pre_sbert_concat %>% bind_cols(readRDS('post_sbert_concat.RData')  %>% as_tibble()) %>% mutate(tangram=str_sub(target,-5,-5))



```

How different are average versus concat embeddings:

```{r}
# if there was only ever one line, it doesn't matter which approach
test <- ssb %>%
  mutate(tangram=str_sub(target,-5,-5)) %>% 
  group_by(gameId,targetNum,repNum, trialNum, numPlayers,playerId,tangram,role) %>% 
  summarize(across(starts_with('V'), mean),
            n=n()) %>% 
  ungroup() 


cols <- test %>% filter(n>1) %>% select(-starts_with("V"), -n)
concat_select <- sbert_concat %>% select(gameId,targetNum,repNum, trialNum, numPlayers,playerId,tangram,role, starts_with("V")) %>% inner_join(cols) %>% mutate(type="concat") %>% union(test %>% filter(n>1) %>% select(-n) %>% mutate(type="average"))

F_mat_test <- concat_select %>% select(starts_with("V")) %>% as.matrix() #Features
M_mat_test <- concat_select %>% select(-starts_with("V")) %>% mutate(feature_ind=row_number())
```

`r test %>% filter(n>1) %>% nrow()` of the `r `test %>% nrow()` person-trial combos were single line utterances to begin with, so these are the same embedding regardless of method. 

```{r helpers}
# note: cor expects features to be in columns so we transpose
get_sim_matrix = function(df, F_mat, method = 'cosine') {
  feats = F_mat[df$feature_ind,]
  if(method == 'cor') {
    return(cor(t(feats), method = 'pearson'))
  } else if (method == 'euclidean') {
    return(as.matrix(dist(feats, method = 'euclidean')))
  } else if (method == 'cosine') {
    return(as.matrix(lsa::cosine(t(feats))))
  } else {
    stop(paste0('unknown method', method))
  }
}

# note this does de-duplicated version
flatten_sim_matrix <- function(cormat, ids) {
  ut <- upper.tri(cormat)
  data.frame(
    dim1 = ids[row(cormat)[ut]],
    dim2 = ids[col(cormat)[ut]],
    sim  = as.numeric(cormat[ut])
  ) %>%
    mutate(dim1 = as.character(dim1),
           dim2 = as.character(dim2))
}

make_within_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          .$repNum)) %>%
    mutate(rep1 = as.numeric(dim1), 
           rep2 = as.numeric(dim2)) 
}

make_across_df <- function(M_mat, F_mat, method) {
  M_mat %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_mat, method = method),
                          as.character(.$combinedId)))
}
```

```{r }

foobar <- M_mat_test %>% 
  group_by(gameId,targetNum,repNum, trialNum, numPlayers,playerId,tangram,role) %>% 
  mutate(combinedId=type) %>% 
  make_across_df(F_mat_test, 'cosine') %>% 
  separate(dim1, into=c("type_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("type_2"), convert=T, sep="_") %>% 
  filter(type_1!=type_2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup()

```

Of the others, this is the cosine similarity distribution between the two methods (grouped by player count). 

```{r}
ggplot(foobar, aes(x=sim))+geom_density()+geom_boxplot()+facet_wrap(~numPlayers)
```
So, average similarity is .87ish for that half (and 1 for the just identical half), but there are some outliers thare lower than .8. 

Switching below diagrams to use concatenate method. 

(Still questions about cleaning etc.)

```{r}
#F_mat <- grouped %>% select(starts_with("V")) %>% as.matrix() #Features
#M_mat <- grouped %>% select(-starts_with("V")) %>% mutate(feature_ind=row_number())

F_mat <- sbert_concat %>% select(starts_with("V")) %>% as.matrix() #Features
M_mat <- sbert_concat %>% select(-starts_with("V")) %>% mutate(feature_ind=row_number())
```

# Caveats to interpretation

This is done on the raw transcripts. Some things that could contribute to "similarity" include larger strings (because there will be averaging, which tends to bring things in) and more non-reference language which we expect to be more uniform (maybe?). 

We could attempt to "solve" these in future by a) annotating for the "reference" expression (or using cleaned transcript as a half way point).


# Across game divergence: 

Do tangram descriptions diverge sooner in smaller groups?
How similar are descriptions of the same tangram in the same block across games?

(only looking at speaker utts)

Within the same tangram, repNum, and numPlayers, but across different games

```{r }

game_divergence <- M_mat %>% 
  filter(role=="speaker") %>% 
  group_by(tangram,repNum, numPlayers) %>% 
  mutate(combinedId=str_c(gameId,repNum,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("gameId_1","repNum_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("gameId_2","repNum_2"), convert=T, sep="_") %>% 
  filter(gameId_1!=gameId_2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  ungroup()

```

```{r}
ggplot(game_divergence, aes(x=repNum,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)
```

Similarity is higher in larger games and earlier in the games. 
See that 6noro starts out looking like a 6p games and ends looking like a 2-3 player game.

We check again allowing games to vary by number of players, but only by 1. 

Within the same tangram, repNum, and numPlayers, but across different games

```{r }

game_divergence_across <- M_mat %>% 
  filter(role=="speaker") %>% 
  filter(numPlayers!="6noro") %>% 
  group_by(tangram,repNum,) %>% 
  mutate(combinedId=str_c(numPlayers,gameId,repNum,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("nP1","gameId_1","repNum_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("nP2","gameId_2","repNum_2"), convert=T, sep="_") %>% 
  filter(gameId_1!=gameId_2) %>% 
  ungroup() %>% 
  mutate(largernP=ifelse(nP1>nP2,nP1,nP2),
         smallernP=ifelse(nP1>nP2,nP2,nP1)) %>% 
  filter(smallernP+1==largernP) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim))
  
```

```{r}
ggplot(game_divergence_across, aes(x=repNum,y=sim,color=as.factor(smallernP)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)
```


Again, similarity is higher in larger games (so 5-6 more similar than 2-3) and reduces over rounds. (We don't include 6noro here b/c it doesn't have a buddy.)

This is the kinda thing that could be driven by outlier games, so mixed effects would be good, but it's pairwise, so that's at least somewhat complicated.

# Within game specialization

(only looking at speaker utts)

in a game, in a round, how different are the descriptions for different tangrams?

Within game, repNum, numPlayers, between tangrams

```{r }

tangram_distinctive <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(gameId,repNum, numPlayers) %>% 
  mutate(combinedId=tangram) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  rename(tangram1=dim1,tangram2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(tangram1!=tangram2) %>% 
  ungroup()
```

```{r}
ggplot(tangram_distinctive, aes(x=repNum,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)
```
Again 6noro starts off looking like a 6p and ends looking like a 2p game. 

```{r, eval=F}
m_distinctive <- lmer(sim~repNum_1*numPlayers_1+(1|gameId), data=tangram_distinctive)

summary(m_distinctive)
```

Earlier reps have more similarity, as do large games. 


# Tangram description evolution
How similar is a tangram description on round N to N+1 as a function of rep and game size?

```{r }

tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(tangram, gameId, numPlayers) %>% 
  mutate(combinedId=str_c(repNum,playerId,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","p1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","p2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1),
         samespeaker=ifelse(p1==p2,"same_speaker","diff_speaker")) 

adjacent <- tangram_change %>% 
  filter(earlier+1==later) %>% 
  ungroup()
```

```{r}
ggplot(adjacent, aes(x=earlier,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)
```

6noro has really similar descriptions throughout. 

Pairs of adjacent rounds have more similar descriptions when the rounds are later (4-5 is closer than 0-1). Descriptions are more similar with larger groups in 0-1, but less similar in larger groups in 2-3, 3-4, and 4-5.

## Speaker sim to first round



```{r}

to_first <- tangram_change %>% filter(earlier==0) %>% ungroup()
ggplot(to_first, aes(x=later,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)

```

## Speaker sim to last round

```{r}

to_last <- tangram_change %>% filter(later==5) %>% ungroup()
ggplot(to_last, aes(x=earlier,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)

```
Here's where 6noro really looks like a 2p game. 

## sample transcript

A semi-random selection of games & tangrams, trying to get some diversity.

```{r}
sample_text <- pre_sbert %>% filter(gameId=="zqcX66GZiQS8bA6Ff") %>% 
  filter(role=="speaker") %>% 
  filter(target=="/experiment/tangram_A.png") %>% 
  group_by(repNum) %>% 
  summarize(text=str_c(sentence, collapse=" "))

distances <- tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  filter(gameId=="zqcX66GZiQS8bA6Ff") %>% 
  filter(tangram=="A") %>% 
  group_by(tangram, gameId, numPlayers) %>% 
  mutate(combinedId=str_c(repNum,tangram,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","target_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","target_2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1)) %>% 
  #filter(earlier+1==later) %>% 
  ungroup() %>% select(later,earlier,sim)

distances %>% left_join(sample_text, by=c("earlier"="repNum")) %>% 
  rename(earlierText=text) %>% left_join(sample_text, by=c("later"="repNum")) %>% 
  rename(laterText=text) %>% select(earlier,later,earlierText,laterText,sim) %>% 
  arrange(earlier,later) %>% 
  knitr::kable(align=c("l"))
```

```{r}
sample_text <- pre_sbert %>% filter(gameId=="2928FF7GcrkeFiDkh") %>% 
  filter(role=="speaker") %>% 
  filter(target=="/experiment/tangram_F.png") %>% 
  group_by(repNum) %>% 
  summarize(text=str_c(sentence, collapse=" "))

distances <- tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  filter(gameId=="2928FF7GcrkeFiDkh") %>% 
  filter(tangram=="F") %>% 
  group_by(tangram, gameId, numPlayers) %>% 
  mutate(combinedId=str_c(repNum,tangram,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","target_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","target_2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1)) %>% 
  #filter(earlier+1==later) %>% 
  ungroup() %>% select(earlier,later,sim)

distances %>% left_join(sample_text, by=c("earlier"="repNum")) %>% 
  rename(earlierText=text) %>% left_join(sample_text, by=c("later"="repNum")) %>% 
  rename(laterText=text) %>% select(earlier,later,earlierText,laterText,sim) %>% 
  arrange(earlier,later) %>% 
  knitr::kable(align=c("l"))
```

```{r}
sample_text <- pre_sbert %>% filter(gameId=="znSiJdhs7sWk5xhgA") %>% 
  filter(role=="speaker") %>% 
  filter(target=="/experiment/tangram_E.png") %>% 
  group_by(repNum) %>% 
  summarize(text=str_c(sentence, collapse=" "))

distances <- tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  filter(gameId=="znSiJdhs7sWk5xhgA") %>% 
  filter(tangram=="E") %>% 
  group_by(tangram, gameId, numPlayers) %>% 
  mutate(combinedId=str_c(repNum,tangram,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","target_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","target_2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1)) %>% 
  filter(earlier+1==later) %>% 
  ungroup() %>% select(earlier,later,sim)

distances %>% left_join(sample_text, by=c("earlier"="repNum")) %>% 
  rename(earlierText=text) %>% left_join(sample_text, by=c("later"="repNum")) %>% 
  rename(laterText=text) %>% select(earlier,later,earlierText,laterText,sim) %>% 
  arrange(earlier,later) %>% 
  knitr::kable(align=c("l"))
```

```{r}
sample_text <- pre_sbert %>% filter(gameId=="55uXKbqaShw7M2wCX") %>% 
  filter(role=="speaker") %>% 
  filter(target=="/experiment/tangram_E.png") %>% 
  group_by(repNum) %>% 
  summarize(text=str_c(sentence, collapse=" "))

distances <- tangram_change <- M_mat %>% 
    filter(role=="speaker") %>% 
  filter(gameId=="55uXKbqaShw7M2wCX") %>% 
  filter(tangram=="E") %>% 
  group_by(tangram, gameId, numPlayers) %>% 
  mutate(combinedId=str_c(repNum,tangram,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("repNum_1","target_1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("repNum_2","target_2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(!is.na(repNum_1)) %>% 
    mutate(later=ifelse(repNum_1>repNum_2,repNum_1, repNum_2),
         earlier=ifelse(repNum_1>repNum_2,repNum_2, repNum_1)) %>% 
  #filter(earlier+1==later) %>% 
  ungroup() %>% select(earlier,later,sim)

distances %>% left_join(sample_text, by=c("earlier"="repNum")) %>% 
  rename(earlierText=text) %>% left_join(sample_text, by=c("later"="repNum")) %>% 
  rename(laterText=text) %>% select(earlier,later,earlierText,laterText,sim) %>% 
  arrange(earlier,later) %>% 
  knitr::kable(align=c("l"))
```

this example really raises the question of what to do with non-referential language (or dubiously deferential language). Like the sentiment in "good ol" and "our fave" and "haha" is also relevantly similar to later iterations, but it's not "reference per se"? 

We could try to pull just the referential descriptions out?

# Listener - listener - speaker alignment (same round)
Include listener stuff
group within game, within tangram, within round, across utterer

code for includes speaker?

(This is nonsense)

```{r }
reps_with_L <- M_mat %>% filter(role=="listener") %>% select(tangram,gameId,numPlayers,repNum) %>% unique()

# if you don't do this inner join, it is very sad and wants to take forever
lls_same_rep <- M_mat %>% 
  inner_join(reps_with_L) %>% 
  group_by(tangram, gameId, numPlayers, repNum) %>% 
  mutate(combinedId=str_c(playerId,role,sep="_")) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  separate(dim1, into=c("p1","r1"), convert=T, sep="_") %>% 
  separate(dim2, into=c("p2","r2"), convert=T, sep="_") %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
    mutate(has.speaker=ifelse(r1=="speaker","has_speaker",ifelse(r2=="speaker","has_speaker","listeners"))) %>% 
  filter(p1!=p2) %>% 
  ungroup()
```

```{r}
ggplot(lls_same_rep, aes(x=repNum,y=sim,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.01)+geom_smooth(formula=y~poly(x,2))+
    scale_color_viridis(discrete=T, direction=-1)+
  facet_grid(.~has.speaker)

```

# Correlates of success!

We want to look at whether properties of the utterances (like distinctiveness) are related to how successful people were that trial. 

We're going to need to un upper-triangle this!

```{r}

success_ro <- read_rds(here(data_location,"round_results.rds")) %>% 
  select(gameId,repNum,tangram,numPlayers,realCorrect) %>% 
  mutate(pct_correct=realCorrect/(numPlayers-1)) %>% 
  mutate(numPlayers=as.character(numPlayers))

success_no_ro <- read_rds(here(data_location_noro,"round_results.rds")) %>% 
  select(gameId,repNum,tangram,numPlayers,realCorrect) %>% 
  mutate(pct_correct=realCorrect/(numPlayers-1)) %>% 
  mutate(numPlayers="6noro")

success <- success_ro %>% union(success_no_ro)
```


```{r }

tangram_distinctive <- M_mat %>% 
    filter(role=="speaker") %>% 
  group_by(gameId,repNum, numPlayers) %>% 
  mutate(combinedId=tangram) %>% 
  make_across_df(F_mat, 'cosine') %>% 
  rename(tangram1=dim1,tangram2=dim2) %>% 
  mutate(sim = ifelse(is.nan(sim), NA, sim)) %>%
  filter(tangram1!=tangram2) %>% 
  ungroup()
```
First try grouping by rep and game
```{r}
success_grouped <- success %>% group_by(gameId, repNum, numPlayers) %>% summarize(pct_correct=mean(pct_correct))

distinctive_grouped <- tangram_distinctive %>% filter(!is.na(sim)) %>% 
  group_by(gameId, repNum, numPlayers) %>% 
  summarize(sim=mean(sim)) %>% 
  left_join(success_grouped) %>% 
  filter(!is.na(pct_correct)) # should track down source of this discrepancy later!

ggplot(distinctive_grouped, aes(x=sim,y=pct_correct,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.5)+geom_smooth(method = "glm", 
    method.args = list(family = "binomial"), se=F)+
    scale_color_viridis(discrete=T, direction=-1)
```

We can also un upper triangle this to look at a per tangram basis -- we see that more distinctive tangram descriptions (lower similarity) correlate with higher success rates. 

(Note this is a correlation, causality is likely ... complicated and cyclic)

```{r}
distinctive_full <- tangram_distinctive %>% 
  rename(tangram1=tangram2, tangram2=tangram1) %>% 
  union(tangram_distinctive) %>% group_by(tangram1, numPlayers, repNum, gameId) %>% 
  summarize(sim=mean(sim)) %>% 
  rename(tangram=tangram1) %>% 
  left_join(success)

ggplot(distinctive_full, aes(x=sim,y=pct_correct,color=as.factor(numPlayers)))+
         geom_jitter(alpha=.1)+geom_smooth(method = "glm", method.args = list(family = "binomial"), se=T)+
    scale_color_viridis(discrete=T, direction=-1)
```

# TODO future

Is there anything good to do with listener data?

How to look for "same speaker" effects? Would want to do same tangram over all the rounds and then use final (or first round) distance, and same speaker?. Where there's a same speaker is deeply confounded with group size!!!! 
